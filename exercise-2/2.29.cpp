// Упражнение 2.29. С учетом переменных из предыдущих упражнений, какие из
// следующих присовений допустимы? Объясните почему?

int main() {
  int i = -1,  // Допустимо. Тип int не unsigned. Диапазон обычного int
               // от -2147483648 до 2147483647
      &r = 0;  // Недопустимо. Несовпадение типов - литерал является
               // целочисленной константой (const int).

  const int i = -1,  // Допустимо. Нельзя менять значение.
      &r = 0;  // Допустимо. Теперь типы совпадают. В целом тут может быть любой
               // тип.

  const int i2 = i,  // Оk, даже если i не const.
      &r = i;  // Ok, i может быть не константной. Более того, она может быть
               // совершенно другого типа.

  const int *p1 = &i2;  // Ok. Указатель на константу инициализированный
                        // адресом константы.

  int *const p2 = &i2;  // Недопустимо. Несовпадение типов. Указатель должен
                        //  иметь тип const int.

  const int *const p3 =
      &i2;  // Ok. Константный указатель на указатель инициализированный
            // константой. Нельзя поменть значение находящееся по адресу и
            // нельзя изменить сам адрес.

  const int
      &const r2;  // Недопустимо, так как ссылку нужно
                  // всегда инициализировать. Более того, если всё же будет
                  // инициализация, то компилятор заругается на const после & и
                  // скажет, что такого квалификатора там быть не может.

  int i,  // Допустима неинизиализированная переменная. Результат непредсказуем.
      *const cp;  // Недопустимо, так как константу нужно
                  // всегда инициализировать.

  int *p1,  // Допустим неинизиализированный указатель. Результат доступа к
            // значения по адресу непредсказуем.
      *const p2;  // Неа. Константу нужно инициализировать.

  const int ic,  // Константу нужно инициализировать.
      &r = ic;  // Ok, но не ok, так как константный ic не инициализирован.
                // Если будет инициализиация, то всё ok.

  const int *const p3;  // Константный указатель должен быть инициализирован.
                        // (который *const)

  const int *p;  // Ok, адрес можно менять сколько угодно.
                 // Значение по адресу нет.

  i = ic;  // Допустимо присвоение типу int копии значения типа const int.

  p1 = p3;  // Указателю допустимо присвоение копии адреса
            // константного указателя

  p1 = &ic;  // Допустимо. Указателю на константный тип можно присваивать адерс,
             // значение по которому имеет const int. Можно даже любого типа.

  p3 = &ic;  // Неа. В константном указателе нельзя менять адрес.

  p2 = p1;  // Неа. В константном указателе нельзя менять адрес.

  ic = *p3;  // Нельзя менять значение константной переменной.

  // Дополнение: ссылку на константу можно инициализировать переменной почти
  // любого типа. Произойдёт неяввное преобразование через временную переменную
  // с помощью компилятора. С указателем такой метод не сработает.

  // Константному указателю можно присваивать адрес переменной, констность типа
  // которой не известна. То есть типы должны совпадать, но не константность.

  double pi = 3.14;
  const int &pip = pi;

  double pi = 3.14;
  const int *pip = &pi;

  double pi = 3.14;
  const double *pip = &pi;
}