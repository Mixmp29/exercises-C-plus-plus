#include <iostream>
#include <string>

// Упражнение 4.24. Программа, различавшая проходную и непроходную оценку,
// зависела от того факта, что условный оператор имеет правосторонний порядок.
// Опишите, как обрабатывался бы этот оператор, имей он левосторнний порядок.

/* Для ответа на этот вопрос нужно подробнее разобрать то, как работает
 * правосторонний порядок и почему он важен в ходе различия проходной оценки.
 * Под правосторонним порядком понимается правая ассоциативность. Под правой
 * ассоциативностью понимается последовательность вычислений с операторами
 * одинакового приоритета справа налево.
 *
 * К примеру:
 * Возведение степени в python:
 *    x ** y ** z == x ** (y ** z)
 * Группировка будет с правой ассоциативностью.
 *
 * В С# деление реализовано следующим образом:
 *    8 / 4 / 2 == ( 8 / 4 ) / 2
 * Группировка с левой ассоциативнтсью.
 *
 * То есть когда говорият о левостороннем или правосторннем ПОРЯДКЕ имеется в
 * виду то, с какой стороны будут группироваться выраржения.
 */

int main() {
  int grade;
  int finalgrade;

  std::cin >> grade;

  // Для наглядности и работы без ошибок результат оценивания проходного балла
  // будет храниться в числах. Со строками левостороннее разграничение не
  // работает из-за несовпадения типов результатов в условии и выражении.

  // Пример правостороннего порядка без явного разграничения скобками.
  finalgrade = (grade > 90) ? 4 : (grade > 75) ? 3 : (grade >= 60) ? 2 : 1;

  std::cout << finalgrade << std::endl;

  // Пример правостороннего порядка с явным разграниченим скобками.
  finalgrade = (grade > 90) ? 4 : ((grade > 75) ? 3 : ((grade >= 60) ? 2 : 1));

  std::cout << finalgrade << std::endl;

  // Пример левостороннего порядка с явным разграничением скобками. Работа в
  // таком формате некорректна. При любом значении от 60 до условно 100
  // результат всегда будет 2, так как с таким порядком слева от '?' операнд
  // всегда является условием. Цепочка таких условий вне зависимости от
  // результатов в промежутке приведет к  "? 2 : 1" с положительным
  // резлультатом. Если ввести число меньше 60, то цепочка всегда будет
  // отрицательной и приведет к 1.

  // К примеру вводится число 91. Результатом первого условного оператора
  // будет 4. Теперь это релультат является условием для второго вложенного
  // условного оператора и он является true, так как отличен от 0. Следовательно
  // результат второго условного оператора будет 3. Теперь этот результат
  // является условием с true для трерьего вложенного условного оператора.
  // В итоге результат будет 2.

  // Следовательно ответ с таким порядком моежт быть только 2 или 1.
  finalgrade = (((grade > 90) ? 4 : (grade > 75)) ? 3 : (grade >= 60)) ? 2 : 1;

  std::cout << finalgrade << std::endl;
}