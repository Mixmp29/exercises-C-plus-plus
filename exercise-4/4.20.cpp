#include <string>
#include <vector>

// Упражнение 4.20. С учетом того, что iter имеет тип vector<string>::iterator,
// укажите, какие из следующих выражений допустимы, если таковые имеются.
// Объясните поведение допустимых выражений, почему ошибочные не допустимы.

int main() {
  std::vector<std::string> vec;
  std::vector<std::string>::iterator iter = vec.begin();

  *iter++;  // Допустимо. Вернется r-value значение копии итератора до
            // инкремента и возьмется значение через оператор взятия значения.

  (*iter)++;  // Недопустимо. Нельзя применить инкремент к целой строке. По сути
              // здесь двойной массив, и такое выражение пытается прибавить 1 к
              // 1-D размерности. Если бы это был просто вектор типа int, то все
              // было бы ок.

  *iter.empty();  // Недопустимо. Поскольку у оператора взятия члена '.'
                  // приоритет больше чем у оператора взятия значения '*', то
                  // выходит, что здесь идет попытка взятия функции-члена из
                  // адреса в указателе. У адреса нет такой функции.

  iter->empty();  // Допустимо. Взятие значения по адресу и вызов функции-члена
                  // из этого значения, объедененное под оператором '->'.
                  // Эквивалентно (*iter).empty().

  ++*iter;  // Недопустимо. Тоже самое замечание что и к постфиксному оператору
            // инкремента. Если бы был бы одномерный вектор int, то было бы ок.

  iter++->empty();  // Допустимо. Под капотом берется r-value значение копии
                    // итератора до инкремента и l-value значение через оператор
                    // взятия значения, затем идет вызов функции-члена из этого
                    // значения. Все это объеденено под '++' в связке '->'.
                    // Эквивалентно (*iter++).empty.
}