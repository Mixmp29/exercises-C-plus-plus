// Упражнение 13.14. Предположим, что класс numbered имеет стандартный
// конструктор, создающий уникальный последовательный номер для каждого объекта,
// который хранится в переменной-члене mysn. Класс numbered использует
// синтезируемые функции-члены управления копированием и имеет следующие
// функции.

// void f(numbered s) { std::cout << s.mysn << endl; }

// Какой вывод создаст следующий код?

// numbered a, b = a, c = b;
// f(a); f(b); f(c);

// Если предположить что у 'a' номер равен 1, то вывод будет 1 1 1.
// Создание 'a' вызывает конструктор, который присваивает ему уникальный номер.
// При созднии же 'b' и 'c' обычный конструктор вызван не будет, а будет вызван
// конструктор инициализации копирванием, который здесь синтезируемый - все
// значения 'a' будут копированы в 'b' и 'c' без присвоения уникального номера.
// Также стоит заметить, что параметр функции получает копию объекта. Если бы
// присвоение уникального номера работало нормально, то при вызове функции
// каждый раз присваивался бы новый номер. Однако это не работает, синтезируемый
// конструктор копирования попросту копирует уникальный номер 'a' в остальные
// объекты.
