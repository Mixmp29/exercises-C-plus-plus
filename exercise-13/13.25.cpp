// Упражнеие 13.25. Предположим, необходимо определить версию класса StrBlob,
// действующего как значение. Предположим также, что необходио продолжить
// использовать указатель shared_ptr, чтобы класс StrBlobPtr все еще мог
// использовать указатель weak_ptr для вектора. Переделанный класс будет
// нуждаться в конструкторе копий и операторе присвоения копии, но не в
// деструкторе. Объясните, что должны делать конструктор копий и оператор
// присвоения копии. Объясните, почему класс не нуждается в деструкторе.

// Немного сбивает с толку, если вспоминать первоначальную концепцию StrBlob, но
// тут так и требуют, чтобы у каждого объекта указатель указывал на свою область
// памяти.

// Конструктор инициализации копирования попросту копирует вектор путем создания
// умного указателя типа вектора и копирования в него вектора умного указателя
// из объекта, из которого идет копирование.

// Оператор присвоения копированием же должен копировать указатель своего
// правого операнда, почистить левый и только потом копировать из скопированной
// части указатель в левый. Однако учитывая, что это умный указатель, достаточно
// просто создать указатель shared_ptr на копию вектора из указателя левого
// операнда и сразу присвоить его data. Деструктор умного указателя позаботится
// о том, чтобы старое значение по указателю было удалено.

// Напоминание: make_shared<T>(args) возвращает указатель на динамически
// созданный объект, аргументы args которого используются для инициализации
// создаваемого объекта.