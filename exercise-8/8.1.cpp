// Упражнение 8.1. Напишите функцию, получающую и возвращающую ссылку на объект
// класса istream. Функция должна читать данные из потока до тех пор, пока не
// будет достигнут конец файла. Функция дожна выводить прочитанные данные на
// стандартное устройство вывода. Перед возвращением потока врните значения его
// флагов в допустимое состояние.

#include <iostream>
#include <string>

std::istream& read(std::istream& is) {
  // Пусть данными будут типа string.

  std::string str;

  while (!is.eof() && is >> str) {
    std::cout << "----------\n" << str << '\n' << std::endl;
  }

  // is.clear(is.rdstate() & ~is.badbit & ~is.failbit & ~is.eofbit);
  is.clear();  // Эквивалентно.

  // Можно сделать еще так, но это не входит в задание.
  /* int i;
  std::cin >> i;  // В таком случае вытащится "ошибочное значение". */

  return is;
}

int main() { /* read(std::cin); */

  // Пока вдавался в эксперименты заметил прикол. Даже если сбросить все
  // состояния потока записи по умолчанию, элемент внури него никуда не денется,
  // если он не соответствует типу переменной, в которую читается значение.
  // Перед тем как снова использовать поток записи нужно вытащить хранящееся
  // внутри значение переменной нужного типа.

  // К примеру вводятся 4 значения int. Если, к примеру, вторым значением
  // написать строку, то, даже после сброса состояний, значение переменной будет
  // 0, так как в cin хранится строка, а он не может передать его переменной
  // типа int. Для исправления такого поведения достаточно вытащить это
  // значение. (на момент выполнения этого задания в книге не поднимался
  // вопрос такого контекста, поэтому быстро нашел только такое решение в
  // интернете, может можно чего лучше сделать).

  int i;
  std::cin >> i;
  std::cin >> i;

  std::cout << "--------------" << std::endl;

  std::cout << std::cin.bad() << std::endl;
  std::cout << std::cin.fail() << std::endl;
  std::cout << std::cin.eof() << std::endl;
  std::cout << std::cin.good() << std::endl;

  std::cout << "--------------" << std::endl;

  if (std::cin.fail()) {
    std::cin.clear();  // Если закомментировать этот оператор, то результат в
                       // любом случае будет 0 при ошибке, так как ввод в cin
                       // будет работать только со статусами без ошибок.

    std::cout << std::cin.bad() << std::endl;
    std::cout << std::cin.fail() << std::endl;
    std::cout << std::cin.eof() << std::endl;
    std::cout << std::cin.good() << std::endl;

    // Такое решение, конечно, довольно корявое.
    std::string s;
    std::cin >> s;  // Если закомментировать этот оператор, то также будет 0 в
                    // любом случае, так как в cin еще осталась строка.

    std::cout << "--------------" << std::endl;
  }

  std::cin >> i;
  std::cin >> i;
  std::cout << i << std::endl;
}