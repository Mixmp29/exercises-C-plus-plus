#include <iostream>
#include <vector>

// Упражнение 3.34. С учетом, что указатели p1 и p2 указывают на элементы в том
// же массиве, что делает следующий код? Какие значения p1 и p2 делают этот код
// недопустимым?

int main() {
  int array[] = {1, 2, 3, 4, 5};  // Массив из 5 элементов.
  int *p1 = array + 1;  // взятие адреса значения array[1].
                        // Эквивалентно *p1 = &array[1]. p1 указывает
                        // на элемент со значением 2.
  int *p2 = &array[4];

  p1 += p2 - p1;  // Разница между указателями выдасть расстояние между нимими -
                  // сколько нужно прибавить к p1, чтобы дойти до p2. Затем, с
                  // помощью составного оператора, это значение прибавляется к
                  // p1 и присваимвается в него же. То есть p1 сдвинулся на
                  // значение расстояния между p1 и p2 и теперь указывает на
                  // элемент, на который указывает p2.

  // Если p1 и p2 указывают на элементы одного и того же массива, то при любом
  // значении это выражение будет верным. Оно в любом случае поставит p1 на p2,
  // даже если p1 будет находиться дальше p2: p1 просто отодвинется назад до
  // нужного значения.
  // Данное выражение будет недопустимым, если p1 и p2 указывают на разные
  // массивы. Или же вовсе на переменные.

  // Далее эксперименты

  std::vector<int> vec{1, 2, 3, 4, 5};
  p1 = array + 1;
  int *pv1 = &vec[1];
  int *pv2 = &vec[4];

  std::cout << p2 - p1 << std::endl;
  std::cout << p1 - p2
            << std::endl;  // Покажет сколько нужно
                           // добавить к p2, чтобы достигнуть p1.
                           // В данном случае к p2 будет прибавлено
                           // отрицательное значение для достижения до p1.
  std::cout << pv1 - pv2 << std::endl;  // Также допустимо для веторов.
}