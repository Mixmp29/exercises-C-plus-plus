// Упражнение 3.26. Почему в программе двоичного поиска на стр. 160 использован
// код min = beg + (end - beg) / 2; , а не mid = (beg + end) / 2; ?

/*
  end - beg. Разница итераторов выдаст знакчение, которое показывает сколько
  нужно прибавть к beg, чтобы достичь end. Таким образом можно узнать размер
  последовательности нужной области. Потом можно поделить это значение на 2,
  чтобы получить значение, которое можно прибавить к beg, чтобы достичь середины
  нужной последовательности.

  beg + end. В языке не предусмотрено работы оператора + между итератормами.
  Даже если предположить, что он есть, то его логика непонятна: возвратится
  значение или итератор? А если итератор, то как его поделить на 2, если это
  адрес? Если это значение, то что даст присвоение итератору mid целочисленного
  значения? В общем это неверная запись.
 */