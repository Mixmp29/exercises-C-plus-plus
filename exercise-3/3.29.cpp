#include <iostream>

// Упражнение 3.29. Перечистиле некоторые из недостатков использования массива
// вместо вектора.

/*
  * Нельзя легко добавлять элементы и менять размер массива
  * Обязательно нужно указывать размер константного (в зависимости от
    компилятора) значения больше нуля.
  * Неочивидная и запутанная работа с указателями (итераторамми) массива.

  В целом использовани вектора гораздо удобнее и понятнее массива, однако стоит
  учитывать, что технически использование массива может ускорить работу
  программы, но это требует от пользователя соответствующие знания и опыт
  работы с самими массивами.
 */

int main() {
  int arr[3] = {1, 2, 3};
  int(&refarr)[3] = arr;
  int(*parr)[3] = &arr;  // Здесь взят указатель на весь массив, а не на его
                         // первый элемент, поэтому, чтобы получить доступ к
                         // массиву нужно использовать оператор обращения *. То
                         // есть взять адрес вообще на весь массив. Что-то типа
                         // адреса, где хранится последовательность адресов, по
                         // которым лежат значения элементов массива.

  std::cout
      << "arr: " << *(arr + 1)
      << std::endl;  // Если просто использовать имя массива для доступа к
                     // данным, то работа схожа с итераторами. Берется
                     // адрес на первый элемент и делается шаг на
                     // позицию следующего элемента. Встроенное индексирование
                     // под капотом работает таким же образом. В книге дальше
                     // будет описано что это и как оно работает.

  std::cout << "refarr: " << refarr[1]
            << std::endl;  // Работа с ссылками очевидна.

  std::cout << "parr 1 method: " << *(*parr + 1)
            << std::endl;  // Получили адрес на arr, то есть на первый элемент,
                           // и сделали шаг на следующую позицию элемента.
                           // Эквивалентно первому вызову cout.

  std::cout << "parr 2 method: " << *(parr[0] + 1)
            << std::endl;  // Сделали тоже самое что и выше. Только тут получили
                           // ссылку на адрес первого элемента arr и потом
                           // сделали шаг на позицию вперед.

  std::cout << "parr 3 method: " << (*parr)[1]
            << std::endl;  // Получили адресс на arr, использовали оператор
                           // индексирования для доступа к элементу.
}