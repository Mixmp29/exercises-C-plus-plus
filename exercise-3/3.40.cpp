#include <cstring>
#include <iostream>

// Упражнение 3.40. Напишите программу, определяющую два символьных массива,
// инициализированных строковыми литералами. Теперь определите третий символьный
// массив для содержания результата конкатенации этих двух массивов. Используйте
// функции strcpy() и strcat() для копирования этих двух массивов в третий.

int main() {
  char ca1[] = "string 1";
  char ca2[] = " and string 2";
  char ca3[strlen(ca1) + strlen(ca2) + 1];
  // Стоит обратить внимание, что функция strlen() возвращает длину массива без
  // учета нулевого символа '\0'. Этот символ также занимает позицию в массиве,
  // поэтому для него тоже нужно выделить память на 1 больше.

  strcpy(ca3, ca1);
  strcat(ca3, ca2);

  std::cout << ca3[11] << std::endl;

  std::cout << strlen(ca3) << std::endl;  // Размер 22 - Ok, количество символов
                                          // соответствуют значению из strlen().

  std::cout << sizeof(ca3) << std::endl;  // Размер 23 - Ok, выделено еще местно
                                          // на 1 для '\0'.

  /* Стоит отметить, что в данном случае не исключено неопределенное поведение,
   * так как даже при размере ca[1] всё равно будет выведена полностью
   * объединённая строка, хотя на деле размеры не изменились. С массивом ca1 при
   * конкатинации вывод остаётся ожидаемым: выведется только string 1, так как
   * больше нет места для конкатенируемого массива ca2. */
}