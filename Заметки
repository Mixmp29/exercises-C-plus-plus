* В цикле while сначала выполняется тело, а потом проверяется условие.


* При сложении значений типов unsigned и int соответственно, будет произведено преобразование int в unsigned.


* Не бывает отрицательных литералов: -42. Знак '-' - это оператор, который инвертирует значение своего операнда (литерала).


* Области видимости позволяют переопределять объекты.


* "обращение к значению указателя на переменную типа int" - получить значение переменной или сам объект, находящийся по адресу, расположенном в указателе, который был объявлен типом int.


* Ссылки и указатели на константы могут инициализироваться любы типом. Компилятор сделает неявное преобразование. Изменять сам объект, на который ссылаются или указывают - нельзя.

* Можно делать константый указатель - в таком указателе нельзя сменить адрес, но можно изменить значение самого объекта.

* Можно совместить указатель на константу и константный указатель - нельзя сменить адрес и нельзя сменить значение объекта.

* constexpr - тоже самое что и const, но с дополнительной проверкой на константное выражение. Если это не будет константное выражение, то компилятор пропишет бан.
К примеру этот пример не будет считаться константным выражением, так как значения функции неизвестно до времени выполнения:
    const int sz = get_size();

Здесь же всё будет нормально, если get_size() будет обозначено как константное выражение, то есть будет являеться функцией constexpr:
    constexpr int sz = get_size();


* constexpr int *pi = nullptr - константный указатель.

  typedef char *pstring;
  const pstring - константный указатель на тип char.

  Тип pstring - это указатель на тип char, а const ptstring - это константный указатель на тип char, но не указатель const char.


* Можно сколько угодно писать const в объявлении переменной. const определится только один раз. Порой нявно может случиться объявление нескольких const, но ничего страшного, он будет считаться за один.
    const int i;
    const auto &ri = i; const int&

* define определеить переменную препроцессора
* ifdef истина, если переменна была определена
* ifndef истина, если переменна не была определена
* endif конец директивы ifdef или ifndef

* vector - шаблон, а не класс. Классом будет то, что было создано этим шаблоном. Для этого следует указать тип хранимого элемента: vector<int>


* Ошибка сегментирования - попытка разделения объекта на сегменты (группы). К примеру индексирование.


* Доступ к члену - доступ к члену (части) объекта, имя которого определено в типе класса этого объекта. Переменная, функция, тип и т.д.


* Если в decltype использовать l-value выражение (отличное от переменной), то оно вернет ссылку: decltype(*p) имеет тип int&. 
* Если в decltype использовать r-value адреса, то оно вернет указатель на указатель: decltype(&p) имеет тип int**.


* Сужающее преобразование невозможно с инициализацией или присвоением списком, поскольку списочная инициализация на уровне компилятора запрещает делать присвоение с потерей информации. К примеру преобразование double в int.
