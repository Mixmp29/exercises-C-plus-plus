// Упражнение 9.25. Что будет, если в программе на стр. 449, гду удалялся
// диапазон элементов, итераторы elem1 и elem2 равны? Что если итератор elem2
// или оба итератора (elem1 и elem2) являются итератором после конца?

// Ничего не произойдет, так как, если elem2 указывает на элемент за последним
// удаляемым, и возвращаемое значение является элементом за последним удаленным,
// то выходит, что функция возвращает elem2.

// В случае первого вороса диапазон удаляемых элементов пуст и функция
// возвращает elem2.

// В случае второго вопроса. Если итератор ялвяется итератором после конца, то
// удалятся элементы от elem1 и до конца. Вернется elem2, то есть end(). Если
// оба итератора на end(), то ничего не удалится и вернется итератор на end().

// Причем интересен случай именно с list. У листа вызов *end() и *(--end())
// возвратит одно и то же значение. Если сделать ++end(), то вернется begin().
// Поведение напоминает кольцевой массив.

#include <iostream>
#include <list>
#include <vector>

int main() {
  std::list<int> ilist = {1, 2, 3};
  /*
    // Ничего не произойдет. Возвратится elem2, то
    // есть итератор на 1.
    auto elem1 = ilist.begin(), elem2 = ++ilist.begin();

    // Ничего не произойдет. Возвратится elem2, то
    // есть итератор на 1. И я не опечатался, ++end() дает begin().
    auto elem1 = ilist.begin(), elem2 = ++ilist.end();

    // // Ничего не произойдет. Возвратится elem2, то
    // есть итератор на 1. Эквивалентно elem1 = begin(), elem2 = begin();
    auto elem1 = ++ilist.end(), elem2 = ++ilist.end();
     */

  // Удалится 1. Возвратится elem2, то есть итератор на 2.
  auto elem1 = ilist.begin(), elem2 = ++(++ilist.end());

  elem1 = ilist.erase(elem1, elem2);

  if (elem1 == ilist.end()) std::cout << *elem1 << std::endl;

  for (auto elem : ilist) std::cout << elem << " ";
  std::cout << std::endl;
}