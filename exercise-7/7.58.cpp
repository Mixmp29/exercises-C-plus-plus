// Упражнение 7.58. Какие из следующих объявлений и определений статических
// переменных-членов являются ошибочными? Объясните почему.

#include <vector>

class constructExample {
  constructExample() = default;
  constructExample(int a) : b(a) {}
  int b;
};

class Example2 {
 public:
  static double rate = 6.5;
  // Нельзя инициализировать статическу переменную внутриклассовым
  // инициализатором, если это не константа или constexpr;

  static const int vecSize = 20;  // Ok. Константная статическая переменная.
  static std::vector<double> vec(vecSize);
  // А вот тут я завтыкал на очень долго. И не из-за того, что тут
  // статический вектор. Этот хороший пример того, почему внутри
  // класса инициализация отличается от остальных областей видимости.

  // Если просто попробовать объявить вектор, то ok.
  std::vector<double> vec;

  // Но если попытаться инициализировать его количеством элемементов по
  // умолчанию (или вызвать любой другой конструктор напрямую), то это
  // определение будет считаться объявлением функции.
  std::vector<double> vec(10);  // <- Просит предоставить тип, а не значение.

  // В учебнике и недолгому поиску в интернете я не нашел точной
  // причины почему сделали такое поведение для области видимости класса, ведь
  // при желании можно сделать функции и конструкторы на определение, но я нашел
  // само правило внутриклассовой инициализации: "При предоставлении
  // внутриклассового инициализатора это следует сделать после знака '=' или в
  // фигурных скобках" на стр. 357.

  // Из этого я сделал вывод, что это скорее всего запрет на вызов конструктора
  // любого другого класса вообще.

  // В следствии чего я задал вопрос нейросетке на сайте nicebot.ru, которая,
  // как уверяют авторы, использует chatGPT 3.5. На запрос "Почему в классе
  // нельзя вызывать конструктор объекта другого класса при внутриклассовой
  // инициализации?" ее ответ:

  /* "В языке C++, конструктор объекта является специальным методом класса,
который вызывается при создании экземпляра этого класса. При внутриклассовой
инициализации, когда один объект инициализируется при помощи другого, возникают
некоторые ограничения.

Во-первых, внутриклассовая инициализация может привести к циклическим
зависимостям. Если класс А инициализируется классом В, а класс В в свою очередь
инициализируется классом А, то возникает проблема в определении порядка
инициализации и конструкторы могут вызываться в бесконечном цикле, что приведет
к ошибке.

Во-вторых, вызов конструктора другого класса может привести к неожиданным
побочным эффектам. Когда мы явно вызываем конструктор другого класса
внутриклассовой инициализации, мы теряем контроль над тем, что происходит с
объектом и какие изменения он вносит. Это может привести к несогласованности
данных или поведения в программе.

В-третьих, внутриклассовая инициализация может нарушить инкапсуляцию класса.
Если мы разрешим вызывать конструктор другого класса при внутриклассовой
инициализации, это может привести к доступу и изменению приватных членов класса,
которые должны быть скрыты и доступны только через публичные методы. Это
нарушает принципы объектно-ориентированного программирования и может привести к
ошибкам и нестабильности программы.

В целом, запрет на вызов конструктора другого класса при внутриклассовой
инициализации - это мера безопасности и способ избежать потенциальных проблем,
связанных с циклическими зависимостями, побочными эффектами и нарушением
инкапсуляции. Это помогает поддерживать четкую структуру и ясную логику
программы." */

  // Затем я подумал, что запрос может быть некорректен, поэтому задал другой:
  // "Почему внутри области видимости класса нельзя вызывать конструктор объекта
  // другого класса? C++.". Ответ:
  /* Внутри области видимости класса нельзя вызывать конструктор объекта другого
класса по нескольким причинам.

1. Ограничение видимости: Конструкторы классов являются специальными методами,
предназначенными для инициализации объектов класса. Однако, внутри области
видимости другого класса, компилятор не имеет доступа к приватным членам первого
класса, включая его конструкторы. Это ограничивает возможность вызова
конструкторов внутри других классов.

2. Изоляция функциональности: Конструкторы классов обычно специально разработаны
для работы с определенными параметрами и инициализации объекта соответствующим
образом. Разработчики обычно стремятся поддерживать инкапсуляцию и изоляцию
функциональности класса, и поэтому не предоставляют доступа к конструкторам
внутри других классов. Это помогает избежать неправильного использования
конструктора или нарушения внутренней логики класса.

3. Проблемы с доступом: Внутри другого класса не всегда гарантировано наличие
доступа к приватным или защищенным членам первого класса. Даже если у нас есть
указатель на объект класса, доступ к его конструктору может быть ограничен из-за
модификаторов доступа.

Однако, в некоторых случаях мы можем достичь похожего эффекта, используя
статические методы или friend-функции. Статические методы могут вызывать
приватные конструкторы и создавать объекты класса внутри самого класса. Как
альтернатива, дружественные функции могут иметь доступ к закрытым конструкторам
и создавать объекты других классов с помощью этого доступа.

В целом, концепция ограничения вызова конструктора других классов внутри области
видимости одного класса является важным аспектом языка C++. Она обеспечивает
четкую организацию классов и предотвращает возможные ошибки связанные с
некорректным использованием конструкторов и логикой объектов. */

  // У меня нет уверенности в этих ответах, но может натолкнуть на некоторые
  // мысли.

  // Запрет на вызов конструктора подтверждает этот пример:
  constructExample example(4);  // Объявление функции.
  constructExample example;  // Объявление объекта типа constructExample.
};

// Если все же возвращаться к заданию упражнения, то сделаю новый класс Example,
// так как пояснения в прошлом были слишком громадными.

class Example {
 public:
  static double rate = 6.5;
  // Нельзя инициализировать статическу переменную внутриклассовым
  // инициализатором, если это не константа или constexpr;

  static const int vecSize = 20;  // Ok. Константная статическая переменная.

  // Как уже стало понятно так делать нельзя.
  // static std::vector<double> vec(vecSize);

  // Просто объявить можно.
  static std::vector<double> vec;
};

double Example::rate;  // Попытка определить статический неконстантный объект,
                       // который нельзя инициализировать внутриклассовым
                       // инициализатором.

const int Example::vecSize;  // Ok, определение статической константной
                             // переменной-члена значением из внутриклассового
                             // инициализатора.

std::vector<double> Example::vec = std::vector<double>(vecSize);
// Определить вектор размера vecSize
// значенями по умолчанию лучше так.

int main() {}