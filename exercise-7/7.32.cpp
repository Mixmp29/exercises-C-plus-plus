// Упражнение 7.32. Оперделите собственные версии классов Screen и Window_mgr, В
// которых функция clear() является членом класса Window_mgr и другом класса
// Screen.

#include <string>
#include <vector>

// Очень много времени убил, чтобы разобраться как и почему что работает. В
// книге уделили этому внимание в целом, но не разжевали. Не совсем понятно было
// по заданию что необходимо иметь в самом Window_mgr. Попробую разбить
// точки интереса по пунктам.

class Screen;  // #3 Для того, чтобы #1 был определен корректно,
               // требуется объявление класса, который будет в нем
               // использоваться. Однако нужно помнить, что такой подход
               // ограничит действия в определении класса. В частности придется
               // убрать определение вектора объектом, инициализированным
               // конструктором Screen(pos ht, pos wd, char c).

class Window_mgr {  // #1 Эта функция нужна сверху и только сверху от класса
                    // Screen, так как в объявлении #2 требуется определенный,
                    // то есть завершенный, класс.
  using ScreenIndex = std::vector<Screen>::size_type;

 public:
  void clear(ScreenIndex);

 private:
  std::vector<Screen> screens;  // #4 Ага, вот тут убрать, но оставить
                                // объявление. Потом можно будет добавить.
};

class Screen {
 public:
  typedef std::string::size_type pos;

  friend void Window_mgr::clear(
      ScreenIndex);  // #2 Для объявления требуется определенный класс
                     // Window_mgr с объявленной функцией-членом внутри него.

  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
};

// Эксперимент по определению класса Window_mrg описан в заголовочном файле
// Window_mgr.h

// Для лучшего понимания того, как работает область видимости классов и их
// членов, можно вооружиться компилятором и отлавливать ошибки. Тогда становится
// все более менее ясно.

// В частности по началу мне было непонятно: где может быть расположен класс
// (сверху или снизу), где можно или нельзя ставить определение самой функции
// clear(), и как работает поиск переменных, классов и функций-членов при
// использовании классов. В книге только потом будет сказано про область
// видимости и как она работает.

// 1) Где может быть расположен класс (сверху или снизу)?
/* Само определение/объявление классов идет точно также как и
 * определение/объявление функций или переменных. То есть, если определять
 * переменные/функции сверху вниз в одной области видимости, то можно быть
 * уверенным, что описанные ранее определения/объявления будут учтены - поиск
 * имени переменной или функции идет вверх от места, где оно использовалось в
 * первый раз. Соответственно, если классу сверху попытаться обратиться к классу
 * снизу, то нижний класс будет считаться неопределенным для верхнего. Для него
 * его как бы нет. Можно объявить нижний перед верхним, но там есть свои
 * ограничения.*/

// 2) Где можно или нельзя ставить определение самой функции clear()?
/* Поскольку это дружественная функция, то объявления и определения можно
 * поставить хоть где в окружающей области видимости класса. Может так
 * показаться на первый взгляд. Действительно, возможность такакя есть, однако
 * стоит помнить, что если поставить определение перед Screen, то класс на
 * момент определения этой функции не определен и является незавершенным
 * классом, из-за этого операторы внутри тела не смогут выполниться.
 */

// 3) Как работает поиск переменных, классов и функций-членов при
// использовании классов (то есть их имен).
/* В целом поиск проводится как и в обычной программе. Стоит только уяснить
   несколько нюсансов:

   3.1) В классе компилятор сначала объявляет все члены
   (переменные, функции), а потом только выполняет их операции.

   Это значит, что:
      * используемое имя в области видимости класса будет искать свое объявление
        как сверху от себя (смотрит предшествующие операции), так и после себя.
      * если это функция-член, то в теле ищет предшествующее объявление, если не
        нашло, то выходит в окружающую область видимости, то есть в область
        видимости класса, где поиск проходит как в описанном подпункте выше.
      * если и в классе нет, то смотрит объявления перед классом (только
        сверху).

   3.2) Если объявлена функция-член и ее определение находится вне класса, то ее
   поиск определения будет проводиться как вверх, так и вниз по программе внутри
   заголовочного файла. Однако стоит помнить, что если определить функцию-член
   перед классом, то имя класса будет считаться нобъявленным или незавершенным.
   А незавершенным классом определять функции нельзя.

   3.2.2) Отдельное внимание дружественным членам. На стр. 365 есть предложение:
   "Классы и функции, не являющиеся членами лкасса, не следует объявлять прежде,
   чем они будут использованы в объявлении дружественными.". Казалось бы дальше
   пойдет пояснение этого предложения, но видимо читателей просто поставили
   перед фактом и продолжили перечислять свойства объявления friend void func().
   Попробую объяснить здесь как я понял:
      * если объявить функцию друга, где в любой части объявления будет
        использован необъявленный/неопределенный класс, то компилятор выдаст
        ошибку о том, что такого класса еще нет.
      * если объявить функцию друга без использования имени
        нобъявленного/неопределенного класса в объявлении, то такая функция как
        друга не будет иметь смысла, так как она не изменяет (или изменяет
        только локальный объект) и не возварщает ни один объект класса.
      * если объявить функцию друга, где в любой части объявления будет
        использован уже объявленный, но не определенный класс, то такой подход
        имеет место быть, но может запутать и использует лишний раз объявление
        класса. Тем более это может усложнить задачу, если объявления будут в
        отдельном заголовочном файле. Это либо в заголовок пихать объявление
        класса, что скорее всего может привести к необычным ошибкам, либо пихать
        include заголовка прямо после объявления и перед определением класса,
        что тоже является довольно странной реализацией.
  В целом поиск имени будет происходить как в 2), но нужно помнить, что
  объявление друга не является объявлением функции.


   3.3) Объвления типа-члена могут быть только сверху от используемого имени.*/

// Все. Большинсто нюансов быстро запоминается, если проверить их компилятором.
// А так поведение поиска объявления имени в целом такое же: большинство поисков
// идет вверх, иногда вниз, отдельно объявлены заранее члены класса.

/*
{
  окружающая область видимости
  {
    область видимости
  }
} */

int main() {}