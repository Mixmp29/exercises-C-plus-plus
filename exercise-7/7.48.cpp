// Упражнение 7.48. С учетом того, что конструктор sales_data() не является
// явным, какие операции происходят во время следующих определений:

// На данный момент у меня в классе default и string конструкторы объеденены.
// Если же предположить, что default версия отдельна, то эти определения просто
// вызовут конструктор string. Так что особой разницы нет. Тем более
// преобразование делает только конструктор, который имеет один параметр.

#include <string>

#include "Sales_data3.h"

int main() {
  std::string null_isbn(
      "9-999-99999-9");  // Создание объекта типа string с прямой инициализацией
                         // и неявным преобразованием типа const char* в string.

  Sales_data item1(null_isbn);  // Прямая инициализация без преобразований;

  Sales_data item2(
      "9-999-99999-9");  // Прямая инициализация с неявным преобразованим типа
                         // const char* в string.

  // На первый взгляд не совсем понятно, что происходит, так как здесь просто
  // определение объекта, а не вызов функции, где требуется объект Sales_data:
  // будет преобразование с созданием временного объекта или просто
  // преобразование аргумента в тип параметра.

  // Думаю в таком случае происходит вызов конструктора с аргументами, типы
  // которых делают преобразования встроенных и библиотечных типов. То есть
  // преобразование типа аргумента в тип параметра.

  item1.combine(null_isbn);  // <- Это подверждает вот это вызов. Если сделать
                             // конструктор explicit, то работать выражение не
                             // будет, а определения выше будут.

  // Следовательно, если ограничиваться определениями из упражнения, то нет
  // никакой разницы будет ли стоять explicit или нет.
}